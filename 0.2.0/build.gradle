plugins {
	id 'org.jbake.site'
	id 'maven-publish'
	id 'dev.nokee.documentation.javadoc'
	id 'dev.nokee.documentation.jbake-ingredients'
}

ext.minimumGradleVersion = '6.2.1'
ext.minimumJavaVersion = '8'

import groovy.io.FileType

import javax.inject.Inject

import java.util.concurrent.TimeUnit

configurations.all {
	resolutionStrategy { ResolutionStrategy r ->
		r.cacheDynamicVersionsFor(0, TimeUnit.SECONDS)
	}
}

dependencies {
	templates 'dev.nokee.docs:jbake:latest.integration'
	configuration 'dev.nokee.docs:jbake:latest.integration'
}

// Recreate zip files
enum Dsl {
	GROOVY_DSL('groovy-dsl'), KOTLIN_DSL('kotlin-dsl')

	private final String name
	Dsl(String name) {
		this.name = name
	}

	String getName() {
		return name
	}
}
def zips = [:]
file('src/docs/samples').eachFile(FileType.DIRECTORIES) { sampleDir ->
	def zipTasks = []
	zips.put(sampleDir.name, zipTasks)
	Dsl.values().each { dsl ->
		File archiveDir = new File(sampleDir, dsl.name)
		if (archiveDir.exists()) {
			zipTasks << tasks.register("zip${sampleDir.name}${dsl.name}", Zip) {
				from(archiveDir) { exclude '.jbakeignore' }
				archiveBaseName = sampleDir.name.split('-').collect { it.capitalize() }.join('')
				archiveVersion = project.name
				archiveClassifier = dsl.name
			}
		}
	}
}
tasks.named('zipBaked', Zip) {
	dependsOn(zips.values().flatten())
	zips.each {k, v ->
		v.each {
			from(it) { into("docs/${project.name}/samples/$k") }
		}
	}
}

// Stage all files for baking
tasks.named('stage', Sync) {
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE

	from('src/docs') {
		into("content/docs/${project.name}")
		exclude('samples/*/*.html') // Already baked
	}
}

dependencies {
	javadocClasspathLock files('javadoc-classpath-lock.xml')
	javadocSource(fileTree('src/main/java') { include('**/*.java').exclude('**/internal/**') })
}

tasks.named('site', Sync) {
	from('src/docs/samples') {
		into("docs/${project.name}/samples")
		include('*/*.html')
	}
	from(tasks.named('javadoc')) { into("docs/${project.name}/javadoc") }
}


// Create adhoc component for baked elements
// TODO: skip all non baked artifacts
abstract class CreateAdhocBakedComponent implements Plugin<Project> {
	@Override
	void apply(Project project) {
		def baked = getSoftwareComponentFactory().adhoc("baked")
		baked.addVariantsFromConfiguration(project.configurations.bakedElements) {
			def variant = it.configurationVariant;
			for (PublishArtifact artifact : variant.getArtifacts()) {
				if (artifact.type.equals(ArtifactTypeDefinition.DIRECTORY_TYPE)) {
					it.skip()
					break
				}
			}
		}
		project.components.add(baked)
	}

	@Inject
	abstract SoftwareComponentFactory getSoftwareComponentFactory()
}
apply plugin: CreateAdhocBakedComponent

// Configure variant aware publications
publishing {
	publications {
		baked(MavenPublication) {
			from components.baked
		}
	}
}
