plugins {
	id 'org.jbake.site' version '5.0.0'
	id 'maven-publish'
}

import groovy.io.FileType
import javax.inject.Inject

configurations {
	// outgoing
	bakedElements {
		canBeConsumed = true
		canBeResolved = false
		attributes {
			attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake'))
			attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
		}
	}

	// incoming
	assets {
		canBeConsumed = false
		canBeResolved = true
		attributes {
			attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-assets'))
		}
	}

	templates {
		canBeConsumed = false
		canBeResolved = true
		attributes {
			attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-templates'))
		}
	}

	jbakeProperties {
		canBeConsumed = false
		canBeResolved = true
		attributes {
			attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-properties'))
		}
	}
}

dependencies {
	templates 'dev.nokee:docs:latest.integration'
	jbakeProperties 'dev.nokee:docs:latest.integration'
}

// Recreate zip files
enum Dsl {
	GROOVY_DSL('groovy-dsl'), KOTLIN_DSL('kotlin-dsl')

	private final String name
	Dsl(String name) {
		this.name = name
	}

	String getName() {
		return name
	}
}
def zips = []
file('src/docs/samples').eachFile(FileType.DIRECTORIES) { sampleDir ->
	Dsl.values().each { dsl ->
		File archiveDir = new File(sampleDir, dsl.name)
		if (archiveDir.exists()) {
			zips << tasks.register("zip${sampleDir.name}${dsl.name}", Zip) {
				from(archiveDir) { exclude '.jbakeignore' }
				archiveBaseName = sampleDir.name.split('-').collect { it.capitalize() }.join('')
				archiveVersion = project.version
				archiveClassifier = dsl.name
			}
		}
	}
}

// Stage all files for baking
def stageTask = tasks.register('stage', Sync) {
	dependsOn(zips)
	into(layout.buildDirectory.dir('staging'))

	zips.each {
		from(it) { into('assets/zips') }
	}
	from('src/docs') { into("content/docs/${project.name}") }
	from(configurations.templates) { into('templates') }
	from(configurations.jbakeProperties)
}

jbake {
	srcDirName = 'build/staging'
}
def bakeTask = tasks.named('bake') { dependsOn(stageTask) }

// Export outgoing artifact as directory
configurations.bakedElements.outgoing.variants.create('directory').artifact(layout.buildDirectory.dir(jbake.destDirName)) {
	it.type = ArtifactTypeDefinition.DIRECTORY_TYPE
	builtBy(bakeTask)
}

// Export outgoing artifact as zip
def zipTask = tasks.register('zipBakes', Zip) {
	dependsOn(bakeTask)
	from(layout.buildDirectory.dir(jbake.destDirName))
}
configurations.bakedElements.outgoing.artifact(zipTask)

// Create adhoc component for baked elements
abstract class CreateAdhocBakedComponent implements Plugin<Project> {
	@Override
	void apply(Project project) {
		def jbake = getSoftwareComponentFactory().adhoc("jbake")
		jbake.addVariantsFromConfiguration(project.configurations.bakedElements) {
			def variant = it.configurationVariant;
			for (PublishArtifact artifact : variant.getArtifacts()) {
				if (artifact.type.equals(ArtifactTypeDefinition.DIRECTORY_TYPE)) {
					it.skip()
					break
				}
			}
		}
		project.components.add(jbake)
	}

	@Inject
	abstract SoftwareComponentFactory getSoftwareComponentFactory()
}
apply plugin: CreateAdhocBakedComponent

// Configure variant aware publications
publishing {
	publications {
		baked(MavenPublication) {
			from components.jbake
		}
	}
}
