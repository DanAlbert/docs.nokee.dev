plugins {
	id 'org.jbake.site' version '5.0.0'
	id 'maven-publish'
}

import groovy.io.FileType
import org.gradle.api.internal.artifacts.transform.UnzipTransform

import javax.inject.Inject

import static org.gradle.api.artifacts.type.ArtifactTypeDefinition.DIRECTORY_TYPE
import static org.gradle.api.artifacts.type.ArtifactTypeDefinition.ZIP_TYPE

def ARTIFACT_FORMAT = Attribute.of("artifactType", String)

configurations {
	// outgoing
	bakedElements {
		canBeConsumed = true
		canBeResolved = false
		attributes {
			attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake'))
			attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
		}
	}

	// incoming
	assets {
		canBeConsumed = false
		canBeResolved = true
		attributes {
			attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-assets'))
			attribute(ARTIFACT_FORMAT, DIRECTORY_TYPE)
		}
	}

	templates {
		canBeConsumed = false
		canBeResolved = true
		attributes {
			attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-templates'))
			attribute(ARTIFACT_FORMAT, DIRECTORY_TYPE)
		}
	}

	jbakeProperties {
		canBeConsumed = false
		canBeResolved = true
		attributes {
			attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-properties'))
		}
	}
}

dependencies.registerTransform(UnzipTransform.class) { variantTransform ->
	variantTransform.getFrom().attribute(ARTIFACT_FORMAT, ZIP_TYPE);
	variantTransform.getFrom().attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-templates'));
	variantTransform.getTo().attribute(ARTIFACT_FORMAT, DIRECTORY_TYPE);
	variantTransform.getTo().attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-templates'));
}

dependencies.registerTransform(UnzipTransform.class) { variantTransform ->
	variantTransform.getFrom().attribute(ARTIFACT_FORMAT, ZIP_TYPE);
	variantTransform.getFrom().attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-assets'));
	variantTransform.getTo().attribute(ARTIFACT_FORMAT, DIRECTORY_TYPE);
	variantTransform.getTo().attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jbake-assets'));
}

dependencies {
	templates 'dev.nokee:docs:latest.integration'
	jbakeProperties 'dev.nokee:docs:latest.integration'
}

repositories {
	maven {
		url = 'https://dl.bintray.com/nokeedev/documentations'
	}
}

// Recreate zip files
enum Dsl {
	GROOVY_DSL('groovy-dsl'), KOTLIN_DSL('kotlin-dsl')

	private final String name
	Dsl(String name) {
		this.name = name
	}

	String getName() {
		return name
	}
}
def zips = []
file('src/docs/samples').eachFile(FileType.DIRECTORIES) { sampleDir ->
	Dsl.values().each { dsl ->
		File archiveDir = new File(sampleDir, dsl.name)
		if (archiveDir.exists()) {
			zips << tasks.register("zip${sampleDir.name}${dsl.name}", Zip) {
				from(archiveDir) { exclude '.jbakeignore' }
				archiveBaseName = sampleDir.name.split('-').collect { it.capitalize() }.join('')
				archiveVersion = project.version
				archiveClassifier = dsl.name
			}
		}
	}
}

// Construct jbake.properties
def generateJBakeConfiguration = tasks.register('generateJBakeConfiguration') {
	def outputFile = layout.buildDirectory.file('generated/jbake.properties')
	inputs.files(configurations.jbakeProperties)
	outputs.file(outputFile)
	doLast {
		def result = new Properties()
		configurations.jbakeProperties.singleFile.withInputStream {
			def p = new Properties()
			p.load(it)
			result.putAll(p)
		}
		outputFile.get().asFile.parentFile.mkdirs()
		outputFile.get().asFile.withOutputStream {
			result.store(it, "")
		}
	}
}

// Stage all files for baking
def stageTask = tasks.register('stage', Sync) {
	dependsOn(zips)
	into(layout.buildDirectory.dir('staging'))

	zips.each {
		from(it) { into('assets/zips') }
	}
	from('src/docs') { into("content/docs/${project.name}") }
	from(configurations.templates) { into('templates') }
	from(generateJBakeConfiguration)
}

jbake {
	srcDirName = 'build/staging'
}
def bakeTask = tasks.named('bake') { dependsOn(stageTask) }

// Export outgoing artifact as directory
configurations.bakedElements.outgoing.variants.create('directory').artifact(layout.buildDirectory.dir(jbake.destDirName)) {
	it.type = ArtifactTypeDefinition.DIRECTORY_TYPE
	builtBy(bakeTask)
}

// Export outgoing artifact as zip
def zipTask = tasks.register('zipBakes', Zip) {
	dependsOn(bakeTask)
	from(layout.buildDirectory.dir(jbake.destDirName))
}
configurations.bakedElements.outgoing.artifact(zipTask)

// Create adhoc component for baked elements
abstract class CreateAdhocBakedComponent implements Plugin<Project> {
	@Override
	void apply(Project project) {
		def jbake = getSoftwareComponentFactory().adhoc("jbake")
		jbake.addVariantsFromConfiguration(project.configurations.bakedElements) {
			def variant = it.configurationVariant;
			for (PublishArtifact artifact : variant.getArtifacts()) {
				if (artifact.type.equals(ArtifactTypeDefinition.DIRECTORY_TYPE)) {
					it.skip()
					break
				}
			}
		}
		project.components.add(jbake)
	}

	@Inject
	abstract SoftwareComponentFactory getSoftwareComponentFactory()
}
apply plugin: CreateAdhocBakedComponent

// Configure variant aware publications
publishing {
	publications {
		baked(MavenPublication) {
			from components.jbake
		}
	}
}
