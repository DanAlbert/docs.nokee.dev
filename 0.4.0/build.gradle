plugins {
	id 'org.jbake.site'
	id 'maven-publish'
	id 'dev.nokee.documentation.javadoc'
	id 'dev.nokee.documentation.jbake-ingredients'
}

ext.minimumGradleVersion = '6.2.1'
ext.minimumJavaVersion = '8'

import groovy.io.FileType

dependencies {
	templates 'dev.nokee.docs:jbake:latest.integration'
	configuration 'dev.nokee.docs:jbake:latest.integration'
}

// Recreate zip files
enum Dsl {
	GROOVY_DSL('groovy-dsl'), KOTLIN_DSL('kotlin-dsl')

	private final String name
	Dsl(String name) {
		this.name = name
	}

	String getName() {
		return name
	}
}
def zips = [:]
file('src/docs/samples').eachFile(FileType.DIRECTORIES) { sampleDir ->
	def zipTasks = []
	zips.put(sampleDir.name, zipTasks)
	Dsl.values().each { dsl ->
		File archiveDir = new File(sampleDir, dsl.name)
		if (archiveDir.exists()) {
			zipTasks << tasks.register("zip${sampleDir.name}${dsl.name}", Zip) {
				from(archiveDir) { exclude '.jbakeignore' }
				archiveBaseName = sampleDir.name.split('-').collect { it.capitalize() }.join('')
				archiveVersion = project.name
				archiveClassifier = dsl.name
			}
		}
	}
}
tasks.named('zipBaked', Zip) {
	into("docs") // Make sure we don't break downstream
}

// Stage all files for baking
tasks.named('stage', Sync) {
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE

	from('src/docs') {
		into("content/${project.name}")
		exclude('samples/*/*.html') // Already baked
	}
}

dependencies {
	javadocClasspathLock files('javadoc-classpath-lock.xml')
	javadocSource(fileTree('src/main/java') { include('**/*.java').exclude('**/internal/**') })
}

tasks.named('site', Sync) {
	from('src/docs/samples') {
		into("${project.name}/samples")
		include('*/*.html')
	}
	dependsOn(zips.values().flatten())
	zips.each {k, v ->
		v.each {
			from(it) { into("${project.name}/samples/$k") }
		}
	}
	from(tasks.named('javadoc')) { into("${project.name}/javadoc") }
}
